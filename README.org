* IMAP Filter, the Rust version                                    :TOC_5_gh:
  - [[#introduction][Introduction]]
  - [[#documentation][Documentation]]
    - [[#installation][Installation]]
    - [[#dsl-is-lua][DSL is Lua]]
  - [[#notes][Notes]]
    - [[#command-line-example][Command Line example]]
    - [[#testing-lua][Testing Lua]]
    - [[#gui-support][GUI support]]
    - [[#examples][Examples]]
      - [[#lua-dsl-example][Lua DSL example]]

** Introduction
   IMAP Filter is a port of RubyGem of the same name.
   We wish to leverage Rust to do this, and also
   to provide more features and the like.
** Documentation
*** Installation
    Everything is based on Lua version 5.3.
    
    You must have Lua installed. On Ubuntu:
    #+begin_src bash
    apt install liblua5.3-dev liblua5.3-0
    #+end_src

    It might also be helpful to have LuaRocks installed. It will
    allow you to use various Lua libraries in your script, though
    you should not need them at all.

    In case you do, refer to:
    https://luarocks.org/
    for the installation instructions and general documentation.

    But generally, you'll want to install this with for lua 5.3. You may
    have an earlier version of Lua installed on your (presumably Linux)
    system. In which case, do the following:

    #+being_src bash
    # installation for a Unix-like system (Linux or macOS, etc.)
    wget https://luarocks.org/releases/luarocks-3.3.0.tar.gz
    tar zxpf luarocks-3.3.0.tar.gz
    cd luarocks-3.3.0
    ./configure --lua-version=5.3 --versioned-rocks-dir && make && sudo make install

    # test that luarocks works.
    sudo luarocks install luasocket
    lua5.3
    # Lua 5.3.5 Copyright (C) 1994-2018 Lua.org, PUC-Rio
    # > require "socket"
    #+end_src

*** DSL is Lua
    We are using Lua as the DSL to implement
    the configuration for the functioning of
    IMAP Filter. The syntax should be close to the
    Ruby DSL, but there will be some differences.

** Notes
   These are my personal notes on this project. They are
   not gauranteed to be in sync or up-to-date or in anyway 
   meaninful to anyone but Yours Truly, and will be 
   deleted from the master branch eventually.
*** Command Line example
    We want to preserve this example so we
    can use it later, if need be.
    #+begin_src rust
fn main() {
    let matches = clap_app!(myapp =>
     (version: "0.0.0")
     (author: "Fred Mithell <fred.mitchell@gmx.de>")
     (about: "IMAP Filter -- a client-independent way to filter your email across many accounts.")
     (@arg CONFIG: -c --config +takes_value "config file?")
     (@arg INPUT: +required "Sppecifies the Lua filter to use")
     (@arg debug: -d ... "Sets the level of debugging information")
     (@arg debug: -t --trial "Trial run. Do not make")
     
     (@subcommand test =>
      (about: "controls testing features")
      (version: "1.3")
      (author: "Someone E. <someone_else@other.com>")
      (@arg verbose: -v --verbose "Print test information verbosely")
      (@subcommand nested_test =>
       (about: "nested subcommands")
       (version: "1.0")
       (author: "Someone E. <someone_else@other.com>")
       (@arg verbose: -v --verbose "Nesting Print test information verbosely")
      )
     )
    )
    .get_matches();

    // Gets a value for config if supplied by user, or defaults to "default.conf"
    let config = matches.value_of("config").unwrap_or("default.conf");
    println!("Value for config: {}", config);

    // Calling .unwrap() is safe here because "INPUT" is required (if "INPUT" wasn't
    // required we could have used an 'if let' to conditionally get the value)
    println!("Using input file: {}", matches.value_of("INPUT").unwrap());

    // Vary the output based on how many times the user used the "verbose" flag
    // (i.e. 'myprog -v -v -v' or 'myprog -vvv' vs 'myprog -v'
    match matches.occurrences_of("v") {
        0 => println!("No verbose info"),
        1 => println!("Some verbose info"),
        2 => println!("Tons of verbose info"),
        3 | _ => println!("Don't be crazy"),
    }

    // You can handle information about subcommands by requesting their matches by name
    // (as below), requesting just the name used, or both at the same time
    if let Some(matches) = matches.subcommand_matches("test") {
        if matches.is_present("debug") {
            println!("Printing debug info...");
        } else {
            println!("Printing normally...");
        }
    }
}
    #+end_src

*** Testing Lua
    #+begin_src rust
fn old_main() {
    Commander::new()
        .options(|app| {
            app.arg(
                Arg::with_name("environment")
                    .short("e")
                    .long("env")
                    .global(true)
                    .takes_value(true)
                    .value_name("STRING")
                    .help("Sets an environment value, defaults to \"dev\""),
            )
        })
        .args(|_args, matches| matches.value_of("environment").unwrap_or("dev"))
        .add_cmd(check::get_cmd())
        .add_cmd(run::get_cmd())
        .no_cmd( |_args, _matches| {
            println!("No subcommand matched");
            Ok(())
        })
        .run()
        .unwrap();
}
    #+end_src

*** TODO GUI support
    not yet.
*** Examples
**** Lua DSL example
     Note that secrets are stored in environment variables,
     rather than the script. We strongly urge you to do the same.

     #+begin_src lua
    -- GMX account 
    account "gmx" {   
       login { user = env 'GMX_EMAIL', pass = env 'GMX_PASS' }
       serv "imap.gmx.net"
       ssl
       auth "login"
       port "993"
    }

    -- Yahoo account
    account "yahoo" {
       login { user = env "YAHOO_EMAIL", pass = env 'YAHOO_PASS' }
       serv 'imap.mail.yahoo.com'
       auth "login"
       tls
    }

    -- Google account
    account "google" {
       login { user = env 'GOOGLE_EMAIL', pass = env 'GOOGLE_PASS' }
       serv "imap.gmail.com"
       auth "plain"
    }

    filter "slashdot" {
       search 'gmx:INBOX' {
          from = 'slashdot',
       }
       mark "seen"
       copy 'google:INBOX'
       move 'gmx:Slashdot'
    }

    filter :github, {
       search 'gmx:INBOX' {
          from 'github.com'
          unseen
       }
       copy 'google:news/Github'
       move 'gmx:Github'
    }

    filter :spam,   {
       search 'gmx:INBOX' {
          from = {'news.brgmedia.com', 'travel.hoteltravel-email.com'}
       }
       delete
    }
    #+end_src
